<?php

/**
 * Implementation of hook_boot(). Runs even for cached pages.
 */
function render_boost_boot() {  
  backdrop_register_shutdown_function('render_boost_shutdown');
}

function microtime_float()
{
    list($usec, $sec) = explode(" ", microtime());
    return ((float)$usec + (float)$sec);
}

function render_boost_shutdown() {

  global $render_boost_count;
  global $render_boost_count_checksum;
  global $render_boost_count_store;
  global $render_boost_count_get;
  global $render_boost_store_ids;
  print "Render boost called: ". $render_boost_count . "\n<br>
  checksum: " . round($render_boost_count_checksum *1000). "ms\n<br>
  store: " . round($render_boost_count_store *1000). "ms\n<br>
  get: " . round($render_boost_count_get*1000). "ms\n<br>
  <pre>" . print_r($render_boost_store_ids,true)."</pre>
  ";
//  print "Render boost called: ". $render_boost_count ."\n<br>";
  
}

function render_boost_checksum($element){
//  $str = var_export($element,true);
  global $render_boost_count;
  global $render_boost_count_checksum;
  $now = microtime_float();
  $render_boost_count++;
  $str = md5(serialize($element));
  $render_boost_count_checksum = $render_boost_count_checksum + (microtime_float() - $now);
  return $str;
}

function render_boost_store_cache($checksum, $data){
  if(empty($data)){
    // do not cache empty
    return;
  }
  global $render_boost_store_ids;
//  $render_boost_store_ids[] = $elements;
  global $render_boost_count_store;
  $now = microtime_float();
  // Construct the filepath where JS translation files are stored.
//  $dir = '/www/bd1.2/files_private/render_boost/' ; //'private://' . settings_get('render_boost_cache_dir', 'render_boost');
//  $dest = $dir . '/' . $checksum . '.html';
//  file_prepare_directory($dir, FILE_CREATE_DIRECTORY);
//  file_unmanaged_save_data($output, $dest);
  $bin = 'cache';
  $cid = $checksum;
  $expire = time() + 3600;
  cache($bin)->set($cid, $data, $expire);
  $render_boost_count_store = $render_boost_count_store + (microtime_float() - $now);
}

function render_boost_get_render_cache($checksum, $elements){
  $return = FALSE;
  if($cache_data = render_boost_get_cache($checksum)){
    foreach($cache_data as $key => $value){
      if($value['#cached']){
        $return .= $value['#data'];
      }else{
        backdrop_render($elements[$key]);
      }
    }
  }

  return $return;
}

function render_boost_set_render_cache($checksum, $cached ,$elements){

}

function render_boost_get_cache($checksum){
  
  global $render_boost_count_get;
  $now = microtime_float();
/*  $dir = '/www/bd1.2/files_private/render_boost/' ; //$dir = 'private://' . settings_get('render_boost_cache_dir', 'render_boost');
  
  $dest = $dir . '/' . $checksum . '.html';

  $source = file_get_contents($dest);
  if(FALSE !== $source){

    if (!empty($elements['#attached'])) {
      backdrop_process_attached($elements);
    }
    $render_boost_count_get = $render_boost_count_get + (microtime_float() - $now);
    return $source;
  }
  */
  $return = FALSE;
  $cid = $checksum;
  $bin='cache';
  if($cache = cache($bin)->get($cid)){

    $return = $cache->data; 
  }
  $render_boost_count_get = $render_boost_count_get + (microtime_float() - $now);
  return $return;
}

function render_boost_backdrop_layout_renderBlock($block) {
  $config = config('render_boost.settings');
  if($config->get('enable')){
    $check_sum = render_boost_checksum($block);
    if($cached_output = render_boost_get_cache($check_sum, $block)){
      return $cached_output;
    }
  }
  return FALSE;
}

function render_boost_backdrop_render(&$elements) {
  $config = config('render_boost.settings');
  
  // Early-return nothing if user does not have access.
  if (empty($elements) || (isset($elements['#access']) && !$elements['#access'])) {
    return '';
  }

  // Do not print elements twice.
  if (!empty($elements['#printed'])) {
    return '';
  }
/*  if($config->get('enable')){
    $check_sum = render_boost_checksum($elements);
    if($cached_output = render_boost_get_render_cache($check_sum, $elements)){
      return $cached_output;
    }
    $elements['#attributes']['cache-checksum'] =  $check_sum;
    $elements['#attributes']['cache-time'] = time();
  }
*/
  
  // Try to fetch the element's markup from cache and return.
  if (isset($elements['#cache'])) {
    $cached_output = backdrop_render_cache_get($elements);
    if ($cached_output !== FALSE) {
      return $cached_output;
    }
  }

  // If #markup is set, ensure #type is set. This allows to specify just #markup
  // on an element without setting #type.
  if (isset($elements['#markup']) && !isset($elements['#type'])) {
    $elements['#type'] = 'markup';
  }

  // If the default values for this element have not been loaded yet, populate
  // them.
  if (isset($elements['#type']) && empty($elements['#defaults_loaded'])) {
    $elements += element_info($elements['#type']);
  }

  // Make any final changes to the element before it is rendered. This means
  // that the $element or the children can be altered or corrected before the
  // element is rendered into the final text.
  if (isset($elements['#pre_render'])) {
    foreach ($elements['#pre_render'] as $function) {
      $elements = $function($elements);
    }
  }

  // Allow #pre_render to abort rendering.
  if (!empty($elements['#printed'])) {
    return '';
  }

//  echo "echo elements";
//  print_r($elements);
// Get the children of the element, sorted by weight.
  $children = element_children($elements, TRUE);
  
  if(isset($elements['#theme']) && $elements['#theme'] != 'pager'){
    $check_sum = render_boost_checksum($elements);
    if($children){
/*       if($data = render_boost_get_array_cache($elements, $children)){
         
       }*/
//       backdrop_set_message( " Children!." . print_r($children,true) . print_r($elements,true));
  //    echo "cache is here!";
  //    print_r($data);
    }else{
      if($cache_data = render_boost_get_cache($check_sum)){
    // Add any JavaScript state information associated with the element.
//        backdrop_set_message( " cache for " . $check_sum . "<pre>" . print_r($elements,true) . "</pre>") ;

        if (!empty($elements['#states'])) {
          backdrop_process_states($elements);
        }
      
        // Add additional libraries, CSS, JavaScript an other custom
        // attached data associated with this element.
        if (!empty($elements['#attached'])) {
          backdrop_process_attached($elements);
        }
  //      print_r($elements);
        return $cache_data;
      }else{
        //print_r($elements);
        backdrop_set_message($check_sum . " - no data." );
        $elements['#attributes']['cache-checksum'] =  $check_sum;
        $elements['#attributes']['cache-time'] = time();
      }
    }
  } else {
    // it's elements array here.
    // Let's cache it all together.
    $keys = array_keys($elements);
    backdrop_set_message( " Is it array?. <pre>" . print_r($keys,true) . print_r($elements,true). "</pre>");
    $check_sum = render_boost_checksum($elements);
    if($cache_data = render_boost_get_cache($check_sum)){
    // Add any JavaScript state information associated with the element.
//        backdrop_set_message( " cache for " . $check_sum . "<pre>" . print_r($elements,true) . "</pre>") ;

        if (!empty($elements['#states'])) {
          backdrop_process_states($elements);
        }
      
        // Add additional libraries, CSS, JavaScript an other custom
        // attached data associated with this element.
        if (!empty($elements['#attached'])) {
          backdrop_process_attached($elements);
        }
  //      print_r($elements);
        return $cache_data;
      }
  }
  /*
    $output = '';
    foreach($data as $key => $value){
      $check_sum = render_boost_checksum($elements[$key]);
    //  echo "checking checksum: " . $check_sum . " == ". $value['#checksum'];
    //  print_r($elements[$key]);
      if($check_sum == $value['#checksum']){
        $output .= $value['#output'];
      }else{
        $output .= drupal_render($elements[$key]);
      }
    }
    return $output;
  }*/


  // Initialize this element's #children, unless a #pre_render callback already
  // preset #children.
  if (!isset($elements['#children'])) {
    $elements['#children'] = '';
  }
  // Call the element's #theme function if it is set. Then any children of the
  // element have to be rendered there.
  if (isset($elements['#theme'])) {
    $elements['#children'] = theme($elements['#theme'], $elements);
  }
  // If #theme was not set and the element has children, render them now.
  // This is the same process as backdrop_render_children() but is inlined
  // for speed.
  $render_cache = FALSE;
  if ($elements['#children'] == '') {
    foreach ($children as $key) {
      $element_tmp = $elements[$key];
      $element_output = backdrop_render($elements[$key]);
      $elements['#children'] .= $element_output;
     /* $render_cache[$key] = array(
        '#checksum' => render_boost_checksum($element_tmp),
        '#elements' =>  $element_tmp,
        '#output' => $element_output,
      );*/
    }
  }
  

  // Let the theme functions in #theme_wrappers add markup around the rendered
  // children.
  if (isset($elements['#theme_wrappers'])) {
    foreach ($elements['#theme_wrappers'] as $theme_wrapper) {
      $elements['#children'] = theme($theme_wrapper, $elements);
    }
  }

  // Filter the outputted content and make any last changes before the
  // content is sent to the browser. The changes are made on $content
  // which allows the output'ed text to be filtered.
  if (isset($elements['#post_render'])) {
    foreach ($elements['#post_render'] as $function) {
      $elements['#children'] = $function($elements['#children'], $elements);
    }
  }

  // Add any JavaScript state information associated with the element.
  if (!empty($elements['#states'])) {
    backdrop_process_states($elements);
  }

  // Add additional libraries, CSS, JavaScript an other custom
  // attached data associated with this element.
  if (!empty($elements['#attached'])) {
    backdrop_process_attached($elements);
  }

  $prefix = isset($elements['#prefix']) ? $elements['#prefix'] : '';
  $suffix = isset($elements['#suffix']) ? $elements['#suffix'] : '';
  $output = $prefix . $elements['#children'] . $suffix;
//  print_r($elements);
//  if($config->get('enable')){
//    print_r($render_cache);
    if($render_cache){
     // render_boost_set_array_cache($render_cache, $elements);
    }else{
      if($elements['#name'] == 'form_build_id'){
        $elements['#printed'] = TRUE;
        return $output;
      }
      if(isset($check_sum)){
        backdrop_set_message("store single cache" . $check_sum . "==|<pre>" . print_r($elements,true) . htmlspecialchars($output) . "</pre>|==");
        if(isset($children)){
          backdrop_set_message("It's children related");
        }
        render_boost_store_cache($check_sum, $output);
      }
    }
//    render_boost_store_cache($check_sum, $elements, $output);*/
    unset($render_cache);
//  }
  // Cache the processed element if #cache is set.
/*  if (isset($elements['#cache'])) {
    backdrop_render_cache_set($output, $elements);
  }*/
/*  
  if($config->get('enable')){
    render_boost_store_cache($check_sum, $elements, $output);
  }
*/
  $elements['#printed'] = TRUE;
  return $output;
}

function render_boost_set_array_cache($render_cache, $elements){
  $keys = array_keys($render_cache);
//  echo "test2";
//  print_r($render_cache);
//  print_r($elements);
  if(isset($elements['#type'])){
    $keys = array(
      '#type' => $elements['#type'],
      '#keys' => $keys,
    );
  }
//  print_r($keys);
  $checksum = render_boost_checksum($keys);
//  echo $checksum;
  render_boost_store_cache($checksum, $render_cache);
}

function render_boost_get_array_cache($elements, $children){
  if($children){
//    echo "children";
//    print_r($children);
    if(isset($elements['#type'])){
      $children = array(
        '#type' => $elements['#type'],
        '#keys' => $children,
      );
    }
    $checksum = render_boost_checksum($children);
//    echo $checksum;  
    return render_boost_get_cache($checksum);

  }
  return FALSE;
}

function render_boost_form_system_performance_settings_alter(&$form, &$form_state, $form_id) {
  $config = config('render_boost.settings');

  $form['render_boost'] = array(
    '#type' => 'fieldset',
    '#title' => t('Render boost'),
    '#tree' => TRUE,
  );

  $form['render_boost']['enable'] = array(
    '#type' => 'checkbox',
    '#title' => t("Enable render boost."),
    '#default_value' => $config->get('enable'),
  );

  $form['#submit'][] = 'render_boost_system_settings_submit';  
}

function render_boost_system_settings_submit($form, &$form_state) {
  $config = config('render_boost.settings');
  $config->set('enable', $form_state['values']['render_boost']['enable']);
  $config->save();
}

function render_boost_original_render(&$elements) {
    // Early-return nothing if user does not have access.
  if (empty($elements) || (isset($elements['#access']) && !$elements['#access'])) {
    return '';
  }

  // Do not print elements twice.
  if (!empty($elements['#printed'])) {
    return '';
  }

  // If #markup is set, ensure #type is set. This allows to specify just #markup
  // on an element without setting #type.
  if (isset($elements['#markup']) && !isset($elements['#type'])) {
    $elements['#type'] = 'markup';
  }

  // If the default values for this element have not been loaded yet, populate
  // them.
  if (isset($elements['#type']) && empty($elements['#defaults_loaded'])) {
    $elements += element_info($elements['#type']);
  }

  // Make any final changes to the element before it is rendered. This means
  // that the $element or the children can be altered or corrected before the
  // element is rendered into the final text.
  if (isset($elements['#pre_render'])) {
    foreach ($elements['#pre_render'] as $function) {
      $elements = $function($elements);
    }
  }

  // Allow #pre_render to abort rendering.
  if (!empty($elements['#printed'])) {
    return '';
  }

  // Get the children of the element, sorted by weight.
  $children = element_children($elements, TRUE);

  // Initialize this element's #children, unless a #pre_render callback already
  // preset #children.
  if (!isset($elements['#children'])) {
    $elements['#children'] = '';
  }
  // Call the element's #theme function if it is set. Then any children of the
  // element have to be rendered there.
  if (isset($elements['#theme'])) {
    $elements['#children'] = theme($elements['#theme'], $elements);
  }
  // If #theme was not set and the element has children, render them now.
  // This is the same process as backdrop_render_children() but is inlined
  // for speed.
  if ($elements['#children'] == '') {
    foreach ($children as $key) {
      $elements['#children'] .= render_boost_original_render($elements[$key]);
    }
  }

  // Let the theme functions in #theme_wrappers add markup around the rendered
  // children.
  if (isset($elements['#theme_wrappers'])) {
    foreach ($elements['#theme_wrappers'] as $theme_wrapper) {
      $elements['#children'] = theme($theme_wrapper, $elements);
    }
  }

  // Filter the outputted content and make any last changes before the
  // content is sent to the browser. The changes are made on $content
  // which allows the output'ed text to be filtered.
  if (isset($elements['#post_render'])) {
    foreach ($elements['#post_render'] as $function) {
      $elements['#children'] = $function($elements['#children'], $elements);
    }
  }

  // Add any JavaScript state information associated with the element.
  if (!empty($elements['#states'])) {
    backdrop_process_states($elements);
  }

  // Add additional libraries, CSS, JavaScript an other custom
  // attached data associated with this element.
  if (!empty($elements['#attached'])) {
    backdrop_process_attached($elements);
  }

  $prefix = isset($elements['#prefix']) ? $elements['#prefix'] : '';
  $suffix = isset($elements['#suffix']) ? $elements['#suffix'] : '';
  $output = $prefix . $elements['#children'] . $suffix;


  $elements['#printed'] = TRUE;
  return $output;
}
